Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_7\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/build/classes\" />\r\n  </component>\r\n  <component name=\"ProjectType\">\r\n    <option name=\"id\" value=\"Android\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision 520e77c0e6fb64e3fce40fa9ae30c7f83e9e1cc0)
+++ .idea/misc.xml	(date 1608775435660)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous/ProgrammingFrameConversionFactor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage org.firstinspires.ftc.teamcode.Autonomous;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\nimport org.firstinspires.ftc.teamcode.ItsComplicated;\r\nimport org.firstinspires.ftc.teamcode.ProgrammingFrame;\r\n\r\n/**\r\n * This file illustrates the concept of driving a path based on encoder counts.\r\n * It uses the common Pushbot hardware class to define the drive on the robot.\r\n * The code is structured as a LinearOpMode\r\n *\r\n * The code REQUIRES that you DO have encoders on the wheels,\r\n *   otherwise you would use: PushbotAutoDriveByTime;\r\n *\r\n *  This code ALSO requires that the drive Motors have been configured such that a positive\r\n *  power command moves them forwards, and causes the encoders to count UP.\r\n *\r\n *   The desired path in this example is:\r\n *   - Drive forward for 48 inches\r\n *   - Spin right for 12 Inches\r\n *   - Drive Backwards for 24 inches\r\n *   - Stop and close the claw.\r\n *\r\n *  The code is written using a method called: encoderDrive(speed, leftInches, rightInches, timeoutS)\r\n *  that performs the actual movement.\r\n *  This methods assumes that each movement is relative to the last stopping place.\r\n *  There are other ways to perform encoder based moves, but this method is probably the simplest.\r\n *  This code uses the RUN_TO_POSITION mode to enable the Motor controllers to generate the run profile\r\n *\r\n * Use Android Studios to Copy this Class, and Paste it into your team's code folder with a new name.\r\n * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\r\n */\r\n\r\n@Autonomous(name=\"ProgrammingFrameConversionFactor\", group=\"ProgrammingFrame\")\r\n//@Disabled\r\npublic class ProgrammingFrameConversionFactor extends LinearOpMode {\r\n\r\n    /* Declare OpMode members. */\r\n    ItsComplicated robot   = new ItsComplicated();   // Use a Pushbot's hardware\r\n    private ElapsedTime     runtime = new ElapsedTime();\r\n\r\n    static final int        TICKS                   = 1000;\r\n    static final double     DRIVE_SPEED             = 0.6;\r\n    static final double     TURN_SPEED              = 0.5;\r\n    static final double     timeoutS                = 20;\r\n\r\n\r\n    public void GoDistanceTICKS(int ticks, double power) {\r\n\r\n\r\n        // Send telemetry message to signify robot waiting;\r\n        telemetry.addData(\"Status\", \"Resetting Encoders\");\r\n        telemetry.update();\r\n\r\n        robot.resetDriveEncoders();\r\n\r\n        // Send telemetry message to indicate successful Encoder reset\r\n        telemetry.addData(\"Path0\", \"Starting at %7d :%7d\",\r\n                robot.frontLeftMotor.getCurrentPosition(),\r\n                robot.frontRightMotor.getCurrentPosition(), robot.backLeftMotor.getCurrentPosition(), robot.backRightMotor.getCurrentPosition());\r\n        telemetry.update();\r\n\r\n        // Wait for the game to start (driver presses PLAY)\r\n\r\n        int FLtarget = robot.frontLeftMotor.getCurrentPosition() + ticks;\r\n        int FRtarget = robot.frontRightMotor.getCurrentPosition() + ticks;\r\n        int BLtarget = robot.backLeftMotor.getCurrentPosition() + ticks;\r\n        int BRtarget = robot.backRightMotor.getCurrentPosition() + ticks;\r\n\r\n        robot.frontLeftMotor.setTargetPosition(FLtarget);\r\n        robot.frontRightMotor.setTargetPosition(FRtarget);\r\n        robot.backLeftMotor.setTargetPosition(BLtarget);\r\n        robot.backRightMotor.setTargetPosition(BRtarget);\r\n\r\n        robot.frontLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        robot.frontRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        robot.backLeftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        robot.backRightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        // reset the timeout time and start motion.\r\n        runtime.reset();\r\n        robot.frontLeftMotor.setPower(-power);\r\n        robot.frontRightMotor.setPower(power);\r\n        robot.backRightMotor.setPower(-power);\r\n        robot.backLeftMotor.setPower(power);\r\n\r\n        // keep looping while we are still active, and there is time left, and both motors are running.\r\n        // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits\r\n        // its target position, the motion will stop.  This is \"safer\" in the event that the robot will\r\n        // always end the motion as soon as possible.\r\n        // However, if you require that BOTH motors have finished their moves before the robot continues\r\n        // onto the next step, use (isBusy() || isBusy()) in the loop test.\r\n        while (opModeIsActive() &&\r\n                (runtime.seconds() < 30) &&\r\n                (Math.abs(robot.frontLeftMotor.getCurrentPosition()) < ticks && Math.abs(robot.frontRightMotor.getCurrentPosition()) < ticks && Math.abs(robot.backLeftMotor.getCurrentPosition()) < ticks && Math.abs(robot.backRightMotor.getCurrentPosition()) < ticks)) {\r\n        }\r\n\r\n        robot.stopDriveMotors();\r\n\r\n        robot.startDriveEncoders();\r\n\r\n        telemetry.addData(\"Path\", \"Complete\");\r\n        telemetry.addData(\"counts\", TICKS);\r\n        telemetry.update();\r\n    }\r\n\r\n\r\n\r\n    public void runOpMode() {\r\n        robot.init(hardwareMap,this);\r\n        waitForStart();\r\n        GoDistanceTICKS(5500, 0.8);\r\n        robot.stopDriveMotors();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous/ProgrammingFrameConversionFactor.java	(revision 520e77c0e6fb64e3fce40fa9ae30c7f83e9e1cc0)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous/ProgrammingFrameConversionFactor.java	(date 1608775681053)
@@ -142,7 +142,7 @@
     public void runOpMode() {
         robot.init(hardwareMap,this);
         waitForStart();
-        GoDistanceTICKS(5500, 0.8);
+        GoDistanceTICKS(5000 0.8);
         robot.stopDriveMotors();
     }
 }
