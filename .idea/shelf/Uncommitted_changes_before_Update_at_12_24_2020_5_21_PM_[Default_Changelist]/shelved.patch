Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_7\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/build/classes\" />\r\n  </component>\r\n  <component name=\"ProjectType\">\r\n    <option name=\"id\" value=\"Android\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision 027108b02d9c8a0e864f19aec3a92c4723fe8b11)
+++ .idea/misc.xml	(date 1608840146346)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ProgrammingFrame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage org.firstinspires.ftc.teamcode;\r\n\r\nimport android.graphics.Color;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.NormalizedColorSensor;\r\nimport com.qualcomm.robotcore.hardware.NormalizedRGBA;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\n\r\n\r\n\r\npublic class ProgrammingFrame\r\n{\r\n\r\n    // define motors\r\n    public DcMotor frontLeftMotor = null;\r\n    public DcMotor frontRightMotor = null;\r\n    public DcMotor backLeftMotor = null;\r\n    public DcMotor backRightMotor = null;\r\n    public DcMotor intake = null;\r\n    public DcMotor shooting = null;\r\n    public Servo servo = null;\r\n\r\n    public NormalizedColorSensor colorSensor1;\r\n    public NormalizedColorSensor colorSensor2;\r\n    public NormalizedColorSensor bottomRing;\r\n    public NormalizedColorSensor topRing;\r\n    public OpMode systemTools;\r\n\r\n\r\n    /* local OpMode members. */\r\n    HardwareMap hwMap           =  null;\r\n    private ElapsedTime period  = new ElapsedTime();\r\n\r\n    /* Constructor */\r\n\r\n    /* Initialize standard Hardware interfaces */\r\n    public void init(HardwareMap ahwMap, OpMode systemToolsIn) {\r\n        // Save reference to Hardware map\r\n        hwMap = ahwMap;\r\n        systemTools = systemToolsIn;\r\n\r\n\r\n        // Define and Initialize Motors\r\n        frontLeftMotor  = hwMap.get(DcMotor.class, \"front_left_drive\");\r\n        frontRightMotor = hwMap.get(DcMotor.class, \"front_right_drive\");\r\n        backLeftMotor = hwMap.get(DcMotor.class, \"back_left_drive\");\r\n        backRightMotor = hwMap.get(DcMotor.class, \"back_right_drive\");\r\n        intake = hwMap.get(DcMotor.class, \"intake\");\r\n        shooting = hwMap.get(DcMotor.class, \"shooting\");\r\n\r\n        // define and initialize servo\r\n        servo = hwMap.get(Servo.class, \"servo\");\r\n\r\n        // set motor directions\r\n        frontLeftMotor.setDirection(DcMotor.Direction.FORWARD);\r\n        frontRightMotor.setDirection(DcMotor.Direction.REVERSE);\r\n        backLeftMotor.setDirection(DcMotor.Direction.FORWARD);\r\n        backRightMotor.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        // set to brake when power is 0\r\n        //backLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        //backRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n\r\n\r\n        // Set all motors to zero power\r\n        stopDriveMotors();\r\n//        frontLeftMotor.setPower(0);\r\n//        frontRightMotor.setPower(0);\r\n//        backLeftMotor.setPower(0);\r\n//        backRightMotor.setPower(0);\r\n\r\n        // Set all motors to run without encoders.\r\n        // May want to use RUN_USING_ENCODERS if encoders are installed.\r\n        startDriveEncoders();\r\n//        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        // Define and initialize ALL installed servos.\r\n        colorSensor1 = hwMap.get(NormalizedColorSensor.class, \"sensor_color\");\r\n        colorSensor2 = hwMap.get(NormalizedColorSensor.class, \"sensor_color2\");\r\n        bottomRing = hwMap.get(NormalizedColorSensor.class, \"sensor_color3\");\r\n        topRing = hwMap.get(NormalizedColorSensor.class, \"sensor_color4\");\r\n\r\n\r\n    }\r\n\r\n    // go distance function\r\n    public void GoDistanceCM(int centimeters, double power, LinearOpMode linearOpMode){\r\n        // holds the conversion factor for ticks to centimeters\r\n        final double conversion_factor = 27.82;\r\n\r\n        // sets the power negative if the distance is negative\r\n        if (centimeters < 0 && power > 0) {\r\n            power = power * -1;\r\n        }\r\n\r\n        // calculates the target amount of motor ticks\r\n        int TICKS = (int) Math.abs(Math.round(centimeters * conversion_factor));\r\n\r\n        // Send telemetry message to signify robot waiting;\r\n        systemTools.telemetry.addData(\"Status\", \"Resetting Encoders\");\r\n        systemTools.telemetry.update();\r\n\r\n        resetDriveEncoders();\r\n//        frontLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        frontRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        backLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        backRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n        // Send telemetry message to indicate successful Encoder reset\r\n        systemTools.telemetry.addData(\"Path0\", \"Starting at %7d :%7d\",\r\n                frontLeftMotor.getCurrentPosition(),\r\n                frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());\r\n        systemTools.telemetry.update();\r\n\r\n        /*\r\n        // sets the target position for each of the motor encoders\r\n        int FLtarget = frontLeftMotor.getCurrentPosition() + TICKS;\r\n        int FRtarget = frontRightMotor.getCurrentPosition() + TICKS;\r\n        int BLtarget = backLeftMotor.getCurrentPosition() + TICKS;\r\n        int BRtarget = backRightMotor.getCurrentPosition() + TICKS;\r\n        M.M. 12/24- Redundant */\r\n\r\n        startDriveEncoders();\r\n\r\n        // reset the timeout time and start motion.\r\n        frontLeftMotor.setPower(power);\r\n        frontRightMotor.setPower(power);\r\n        backRightMotor.setPower(power);\r\n        backLeftMotor.setPower(power);\r\n\r\n        // keep looping while we are still active, and there is time left, and both motors are running.\r\n        // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits\r\n        // its target position, the motion will stop.  This is \"safer\" in the event that the robot will\r\n        // always end the motion as soon as possible.\r\n        // However, if you require that BOTH motors have finished their moves before the robot continues\r\n        // onto the next step, use (isBusy() || isBusy()) in the loop test.\r\n        while (linearOpMode.opModeIsActive() &&\r\n                (Math.abs(frontLeftMotor.getCurrentPosition()) < TICKS && Math.abs(frontRightMotor.getCurrentPosition()) < TICKS && Math.abs(backLeftMotor.getCurrentPosition()) < TICKS && Math.abs(backRightMotor.getCurrentPosition()) < TICKS)) {\r\n        }\r\n\r\n        stopDriveMotors();\r\n//        frontLeftMotor.setPower(0);\r\n//        frontRightMotor.setPower(0);\r\n//        backRightMotor.setPower(0);\r\n//        backLeftMotor.setPower(0);\r\n\r\n        startDriveEncoders();\r\n//        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        systemTools.telemetry.addData(\"Path\", \"Complete\");\r\n        systemTools.telemetry.addData(\"counts\", TICKS);\r\n        systemTools.telemetry.update();\r\n    }\r\n\r\n    // function for rotating the robot\r\n    public void RotateDEG(int degrees, double power, LinearOpMode linearOpMode) {\r\n\r\n        // conversion for degrees to ticks\r\n        final double conversion_factor = 27.82;\r\n\r\n        // if degrees are negative, set the power negative\r\n        if (degrees < 0 && power > 0) {\r\n            power = power * -1;\r\n        }\r\n\r\n        int TICKS = (int) Math.abs(Math.round(degrees * conversion_factor));\r\n        /*\r\n         * Initialize the drive system variables.\r\n         * The init() method of the hardware class does all the work here\r\n         */\r\n\r\n        // Send telemetry message to signify robot waiting;\r\n        systemTools.telemetry.addData(\"Status\", \"Resetting Encoders\");\r\n        systemTools.telemetry.update();\r\n\r\n        resetDriveEncoders();\r\n//        frontLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        frontRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        backLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        backRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n        // Send telemetry message to indicate successful Encoder reset\r\n        systemTools.telemetry.addData(\"Path0\", \"Starting at %7d :%7d\",\r\n                frontLeftMotor.getCurrentPosition(),\r\n                frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());\r\n        systemTools.telemetry.update();\r\n\r\n        // set target position for all the motor encoders\r\n        int FLtarget = frontLeftMotor.getCurrentPosition() + TICKS;\r\n        int FRtarget = frontRightMotor.getCurrentPosition() - TICKS;\r\n        int BLtarget = backLeftMotor.getCurrentPosition() + TICKS;\r\n        int BRtarget = backRightMotor.getCurrentPosition() - TICKS;\r\n\r\n        startDriveEncoders();\r\n\r\n        // reset the timeout time and start motion.\r\n        frontLeftMotor.setPower(power);\r\n        frontRightMotor.setPower(-power);\r\n        backRightMotor.setPower(-power);\r\n        backLeftMotor.setPower(power);\r\n\r\n        // keep looping while we are still active, and there is time left, and both motors are running.\r\n        // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits\r\n        // its target position, the motion will stop.  This is \"safer\" in the event that the robot will\r\n        // always end the motion as soon as possible.\r\n        // However, if you require that BOTH motors have finished their moves before the robot continues\r\n        // onto the next step, use (isBusy() || isBusy()) in the loop test.\r\n        while (linearOpMode.opModeIsActive() &&\r\n                (Math.abs(frontLeftMotor.getCurrentPosition()) < TICKS && Math.abs(frontRightMotor.getCurrentPosition()) < TICKS && Math.abs(backLeftMotor.getCurrentPosition()) < TICKS && Math.abs(backRightMotor.getCurrentPosition()) < TICKS)) {\r\n        }\r\n\r\n        stopDriveMotors();\r\n//        frontLeftMotor.setPower(0);\r\n//        frontRightMotor.setPower(0);\r\n//        backRightMotor.setPower(0);\r\n//        backLeftMotor.setPower(0);\r\n\r\n        startDriveEncoders();\r\n//        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        systemTools.telemetry.addData(\"Path\", \"Complete\");\r\n        systemTools.telemetry.addData(\"counts\", TICKS);\r\n        systemTools.telemetry.update();\r\n    }\r\n\r\n    // robot strafing function\r\n    public void StrafeCM(int centimeters, double power, LinearOpMode linearOpMode){\r\n\r\n        // conversion factor between ticks and centimeters\r\n        final double conversion_factor = 27.82;\r\n\r\n        // if the distance is negative, set power negative\r\n        if (centimeters < 0 && power > 0) {\r\n            power = power * -1;\r\n        }\r\n\r\n        int TICKS = (int) Math.abs(Math.round(centimeters * conversion_factor));\r\n\r\n        // Send telemetry message to signify robot waiting;\r\n        systemTools.telemetry.addData(\"Status\", \"Resetting Encoders\");\r\n        systemTools.telemetry.update();\r\n\r\n        resetDriveEncoders();\r\n//        frontLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        frontRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        backLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//        backRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n        // Send telemetry message to indicate successful Encoder reset\r\n        systemTools.telemetry.addData(\"Path0\", \"Starting at %7d :%7d\",\r\n                frontLeftMotor.getCurrentPosition(),\r\n                frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());\r\n        systemTools.telemetry.update();\r\n\r\n        // set target position for motor encoders\r\n        int FLtarget = frontLeftMotor.getCurrentPosition() - TICKS;\r\n        int FRtarget = frontRightMotor.getCurrentPosition() + TICKS;\r\n        int BLtarget = backLeftMotor.getCurrentPosition() + TICKS;\r\n        int BRtarget = backRightMotor.getCurrentPosition() - TICKS;\r\n\r\n        startDriveEncoders();\r\n\r\n        // after resetting encoders, apply power to the motors\r\n        frontLeftMotor.setPower(-power);\r\n        frontRightMotor.setPower(power);\r\n        backRightMotor.setPower(power);\r\n        backLeftMotor.setPower(-power);\r\n\r\n        // keep looping while we are still active, and there is time left, and both motors are running.\r\n        // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits\r\n        // its target position, the motion will stop.  This is \"safer\" in the event that the robot will\r\n        // always end the motion as soon as possible.\r\n        // However, if you require that BOTH motors have finished their moves before the robot continues\r\n        // onto the next step, use (isBusy() || isBusy()) in the loop test.\r\n        while (linearOpMode.opModeIsActive() &&\r\n                (Math.abs(frontLeftMotor.getCurrentPosition()) < TICKS && Math.abs(frontRightMotor.getCurrentPosition()) < TICKS && Math.abs(backLeftMotor.getCurrentPosition()) < TICKS && Math.abs(backRightMotor.getCurrentPosition()) < TICKS)) {\r\n        }\r\n\r\n        stopDriveMotors();\r\n//        frontLeftMotor.setPower(0);\r\n//        frontRightMotor.setPower(0);\r\n//        backRightMotor.setPower(0);\r\n//        backLeftMotor.setPower(0);\r\n\r\n        startDriveEncoders();\r\n//        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        systemTools.telemetry.addData(\"Path\", \"Complete\");\r\n        systemTools.telemetry.addData(\"counts\", TICKS);\r\n        systemTools.telemetry.update();\r\n    }\r\n\r\n    // find line function\r\n    public void findLine(double power, LinearOpMode linearOpMode) {\r\n        // Send telemetry message to signify robot waiting;\r\n       systemTools.telemetry.addData(\"Status\", \"Resetting Encoders\");\r\n       systemTools.telemetry.update();\r\n\r\n        resetDriveEncoders();\r\n\r\n\r\n        // Send telemetry message to indicate successful Encoder reset\r\n        systemTools.telemetry.addData(\"Path0\", \"Starting at %7d :%7d\",\r\n                frontLeftMotor.getCurrentPosition(),\r\n                frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());\r\n        systemTools.telemetry.update();\r\n\r\n        NormalizedRGBA colors1 = colorSensor1.getNormalizedColors();\r\n        NormalizedRGBA colors2 = colorSensor2.getNormalizedColors();\r\n\r\n        // reset the timeout time and start motion.\r\n        frontLeftMotor.setPower(power);\r\n        frontRightMotor.setPower(power);\r\n        backRightMotor.setPower(power);\r\n        backLeftMotor.setPower(power);\r\n\r\n        // keep looping while we are still active, and there is time left, and both motors are running.\r\n        // When the color sensors detect the line, the motion will stop.  This is \"safer\" in the event that the robot will\r\n        // always end the motion as soon as possible.\r\n        // However, if you require that BOTH motors have finished their moves before the robot continues\r\n        // onto the next step, use (isBusy() || isBusy()) in the loop test.\r\n        while (linearOpMode.opModeIsActive() &&\r\n                //        (runtime.seconds() < 30) &&\r\n                ((colors1.red != 0 && colors1.green != 0 && colors1.blue != 0) || (colors2.red != 0 && colors2.green != 0 && colors2.blue != 0))) {\r\n            colors1 = colorSensor1.getNormalizedColors();\r\n            colors2 = colorSensor2.getNormalizedColors();\r\n        }\r\n\r\n        stopDriveMotors();\r\n\r\n        startDriveEncoders();\r\n\r\n        systemTools.telemetry.addData(\"Path\", \"Complete\");\r\n        systemTools.telemetry.update();\r\n    }\r\n\r\n    public char ringFinder() {\r\n        char path;\r\n        boolean sensor1Detected;\r\n        boolean sensor2Detected;\r\n        float gain = 2;\r\n        int hueTarget = 30;\r\n        final float[] hsvValues = new float[3];\r\n        final float[] hsvValues2 = new float[3];\r\n\r\n        systemTools.telemetry.addData(\"Gain\", gain);\r\n\r\n        // set gain on color sensors\r\n        topRing.setGain(gain);\r\n        bottomRing.setGain(gain);\r\n\r\n        // get color sensors\r\n        NormalizedRGBA colors2 = topRing.getNormalizedColors();\r\n        NormalizedRGBA colors1 = bottomRing.getNormalizedColors();\r\n\r\n        Color.colorToHSV(colors1.toColor(), hsvValues);\r\n        Color.colorToHSV(colors2.toColor(), hsvValues2);\r\n\r\n        // checks if values are within the bounds\r\n        sensor1Detected = hsvValues[0] > 30;\r\n        sensor2Detected = hsvValues2[0] > 30;\r\n\r\n        // return a character determined by the color sensor output\r\n        if (sensor1Detected && sensor2Detected) {\r\n            path = 'C';\r\n        } else if (sensor1Detected && !sensor2Detected) {\r\n            path = 'B';\r\n        } else if (!sensor1Detected && !sensor2Detected) {\r\n            path = 'A';\r\n        } else { // Means there was an error\r\n            path = 'E';\r\n        }\r\n\r\n        systemTools.telemetry.addData(\"Path letter (E is Error): \", path);\r\n        systemTools.telemetry.update();\r\n        return path;\r\n    }\r\n\r\n\r\n    public void stopDriveMotors() {\r\n        frontLeftMotor.setPower(0);\r\n        frontRightMotor.setPower(0);\r\n        backLeftMotor.setPower(0);\r\n        backRightMotor.setPower(0);\r\n    }\r\n\r\n    public void stopAllMotors() {\r\n        stopDriveMotors();\r\n        intake.setPower(0);\r\n        shooting.setPower(0);\r\n    }\r\n\r\n    public void resetDriveEncoders() {\r\n        frontLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        frontRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    public void startDriveEncoders() {\r\n        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n    }\r\n\r\n    public void moveGripper(boolean close) {\r\n        servo.scaleRange(0, 1.0);\r\n        if (close) {\r\n            servo.setDirection(Servo.Direction.FORWARD);\r\n            servo.setPosition(0.25);\r\n        }\r\n        else {\r\n            servo.setDirection(Servo.Direction.REVERSE);\r\n            servo.setPosition(0);\r\n        }\r\n    }\r\n\r\n    public void GoDistanceTICKS(int ticks, double power, LinearOpMode linearOpMode) {\r\n\r\n\r\n        // Send telemetry message to signify robot waiting;\r\n        systemTools.telemetry.addData(\"Status\", \"Resetting Encoders\");\r\n        systemTools.telemetry.update();\r\n\r\n        resetDriveEncoders();\r\n\r\n        // Send telemetry message to indicate successful Encoder reset\r\n        systemTools.telemetry.addData(\"Path0\", \"Starting at %7d :%7d\",\r\n                frontLeftMotor.getCurrentPosition(),\r\n                frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());\r\n        systemTools.telemetry.update();\r\n\r\n        // Wait for the game to start (driver presses PLAY)\r\n\r\n\r\n        // reset the timeout time and start motion.\r\n        frontLeftMotor.setPower(power);\r\n        frontRightMotor.setPower(power);\r\n        backRightMotor.setPower(power);\r\n        backLeftMotor.setPower(power);\r\n\r\n        // keep looping while we are still active, and there is time left, and both motors are running.\r\n        // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits\r\n        // its target position, the motion will stop.  This is \"safer\" in the event that the robot will\r\n        // always end the motion as soon as possible.\r\n        // However, if you require that BOTH motors have finished their moves before the robot continues\r\n        // onto the next step, use (isBusy() || isBusy()) in the loop test.\r\n        while (linearOpMode.opModeIsActive() &&\r\n                (Math.abs(frontLeftMotor.getCurrentPosition()) < ticks && Math.abs(frontRightMotor.getCurrentPosition()) < ticks && Math.abs(backLeftMotor.getCurrentPosition()) < ticks && Math.abs(backRightMotor.getCurrentPosition()) < ticks)) {\r\n        }\r\n\r\n        stopDriveMotors();\r\n\r\n        startDriveEncoders();\r\n\r\n        systemTools.telemetry.addData(\"Path\", \"Complete\");\r\n        systemTools.telemetry.update();\r\n    }\r\n }\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ProgrammingFrame.java	(revision 027108b02d9c8a0e864f19aec3a92c4723fe8b11)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ProgrammingFrame.java	(date 1608846905812)
@@ -139,9 +139,16 @@
         // calculates the target amount of motor ticks
         int TICKS = (int) Math.abs(Math.round(centimeters * conversion_factor));
 
+        // Debug: Send telemetry message with calculated ticks;
+        systemTools.telemetry.addData("Calculated Counts =", TICKS);
+     //   systemTools.telemetry.update();
+
+       // Thread.sleep(2000); // debugging: allow time to view telemetry
+
         // Send telemetry message to signify robot waiting;
+        systemTools.telemetry.addLine();
         systemTools.telemetry.addData("Status", "Resetting Encoders");
-        systemTools.telemetry.update();
+     //   systemTools.telemetry.update();
 
         resetDriveEncoders();
 //        frontLeftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
@@ -151,11 +158,12 @@
 
 
         // Send telemetry message to indicate successful Encoder reset
-        systemTools.telemetry.addData("Path0", "Starting at %7d :%7d",
+        systemTools.telemetry.addLine();
+        systemTools.telemetry.addData("Initial pos.", "Starting at %7d :%7d :%7d :%7d",
                 frontLeftMotor.getCurrentPosition(),
                 frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());
-        systemTools.telemetry.update();
-
+      //  systemTools.telemetry.update();
+      //  wait(2000); // debugging: allow time to view telemetry
         /*
         // sets the target position for each of the motor encoders
         int FLtarget = frontLeftMotor.getCurrentPosition() + TICKS;
@@ -183,20 +191,31 @@
         }
 
         stopDriveMotors();
+
 //        frontLeftMotor.setPower(0);
 //        frontRightMotor.setPower(0);
 //        backRightMotor.setPower(0);
 //        backLeftMotor.setPower(0);
 
-        startDriveEncoders();
+ // fem 12-24  debug       startDriveEncoders();
 //        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
 //        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
 //        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
 //        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
 
+        // Send telemetry message to indicate successful Encoder reset
+        systemTools.telemetry.addLine();
+        systemTools.telemetry.addData("Final", "Starting at %7d :%7d :%7d :%7d",
+                frontLeftMotor.getCurrentPosition(),
+                frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());
+        systemTools.telemetry.update();
+
+        /*
         systemTools.telemetry.addData("Path", "Complete");
         systemTools.telemetry.addData("counts", TICKS);
         systemTools.telemetry.update();
+
+         */
     }
 
     // function for rotating the robot
@@ -475,20 +494,21 @@
 
         // Send telemetry message to signify robot waiting;
         systemTools.telemetry.addData("Status", "Resetting Encoders");
-        systemTools.telemetry.update();
+       // systemTools.telemetry.update();
 
         resetDriveEncoders();
 
+        startDriveEncoders();
         // Send telemetry message to indicate successful Encoder reset
-        systemTools.telemetry.addData("Path0", "Starting at %7d :%7d",
+        systemTools.telemetry.addLine();
+        systemTools.telemetry.addData("Initial pos.", "Starting at %7d :%7d :%7d :%7d",
                 frontLeftMotor.getCurrentPosition(),
                 frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());
-        systemTools.telemetry.update();
 
-        // Wait for the game to start (driver presses PLAY)
+               // Wait for the game to start (driver presses PLAY)
 
 
-        // reset the timeout time and start motion.
+        // start motion.
         frontLeftMotor.setPower(power);
         frontRightMotor.setPower(power);
         backRightMotor.setPower(power);
@@ -507,8 +527,12 @@
         stopDriveMotors();
 
         startDriveEncoders();
+        systemTools.telemetry.addLine();
+        systemTools.telemetry.addData("Final pos.", "Starting at %7d :%7d :%7d :%7d",
+                frontLeftMotor.getCurrentPosition(),
+                frontRightMotor.getCurrentPosition(), backLeftMotor.getCurrentPosition(), backRightMotor.getCurrentPosition());
 
-        systemTools.telemetry.addData("Path", "Complete");
+        systemTools.telemetry.addLine().addData("Path", "Complete");
         systemTools.telemetry.update();
     }
  }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous/AutoLeft1WV1Blue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.Autonomous;\r\n\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\nimport org.firstinspires.ftc.teamcode.ProgrammingFrame;\r\n\r\n@Autonomous(name=\"Left1WobbleTargetBlue\", group=\"Motion\")\r\npublic class AutoLeft1WV1Blue extends LinearOpMode {\r\n    // This program starts on the right line, drops off a wobble goal in it's target,\r\n    // Goes to shoot at the center shooting spot, grabs second wobble goal and drops in it's target,\r\n    // than drives to center shooting spot to park at the end.\r\n    char ringAt;\r\n    ProgrammingFrame robot   = new ProgrammingFrame();\r\n    private ElapsedTime runtime = new ElapsedTime();\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        robot.init(hardwareMap, this);\r\n        waitForStart();\r\n        // Have method(s) that shoot 3 rings here, find out if the team want the 3 rings shot in\r\n        // the Tower Goal, Power Shot Targets, or some mixture of both\r\n        // Driving to the starter stack\r\n        robot.GoDistanceCM(60, .8, this);\r\n        System.exit(1);\r\n        // Detect the rings here and return A, B, C, or E for Error\r\n        ringAt = robot.ringFinder();\r\n       // ringAt = 'A';\r\n        if (ringAt == 'E') {  // Top saw a ring but bottom didn't somehow, try one more time\r\n            ringAt = robot.ringFinder();  // If this fails it will take C path\r\n        }\r\n        // Gets us to the target zone\r\n        robot.StrafeCM(59, .8, this);\r\n        if (ringAt == 'A') {\r\n            robot.GoDistanceCM(59, .8, this);\r\n        }\r\n        else if (ringAt == 'B') {\r\n            robot.GoDistanceCM(118, .8, this);\r\n            robot.StrafeCM(59, .8, this);\r\n        }\r\n        else {\r\n            robot.GoDistanceCM(177, .8, this);\r\n        }\r\n        // Add function that drops a wobble goal\r\n        // Move to the launch line\r\n        if (ringAt == 'A') {\r\n            robot.StrafeCM(59, .8, this);\r\n            robot.GoDistanceCM(27, .8, this);\r\n        }\r\n        else if (ringAt == 'B') {\r\n            robot.GoDistanceCM(-27, .8, this);\r\n        }\r\n        else {\r\n            robot.GoDistanceCM(-86, .8, this);\r\n            robot.StrafeCM(59, .8, this);\r\n        }\r\n        // Comment out the below if we don't have time!!!\r\n        // Use our sensor to make sure we are on the line\r\n        // Backup to make sure we are behind the line\r\n        //robot.GoDistanceCM(-15, .8, this);\r\n        // Line up to the line\r\n        //robot.findLine(.5);\r\n        // Go forward a tiny bit that way we are more centered on the line\r\n        //robot.GoDistanceCM(5, .8, this);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous/AutoLeft1WV1Blue.java	(revision 027108b02d9c8a0e864f19aec3a92c4723fe8b11)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous/AutoLeft1WV1Blue.java	(date 1608847844095)
@@ -23,8 +23,11 @@
         // Have method(s) that shoot 3 rings here, find out if the team want the 3 rings shot in
         // the Tower Goal, Power Shot Targets, or some mixture of both
         // Driving to the starter stack
-        robot.GoDistanceCM(60, .8, this);
+        robot.GoDistanceTICKS(3338, .5, this);
+     //   while (opModeIsActive()) {}
         System.exit(1);
+       /*  Debug: comment out rest of method  FEM 12-24-2020
+
         // Detect the rings here and return A, B, C, or E for Error
         ringAt = robot.ringFinder();
        // ringAt = 'A';
@@ -64,5 +67,14 @@
         //robot.findLine(.5);
         // Go forward a tiny bit that way we are more centered on the line
         //robot.GoDistanceCM(5, .8, this);
+        end of Debug: comment out rest of method  FEM 12-24-2020
+        */
+        telemetry.addLine();
+        telemetry.addData("Final", "Starting at %7d :%7d :%7d :%7d",
+                robot.frontLeftMotor.getCurrentPosition(),
+                robot.frontRightMotor.getCurrentPosition(), robot.backLeftMotor.getCurrentPosition(), robot.backRightMotor.getCurrentPosition());
+        telemetry.update();
+        //while (opModeIsActive()) {}  //  Empty while loop - program waits until user terminates op-mode
+
     }
 }
